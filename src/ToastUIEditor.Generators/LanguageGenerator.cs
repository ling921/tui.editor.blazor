using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace ToastUIEditor.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class LanguageGenerator : ISourceGenerator
{
    private readonly Regex _regex = new(@"^\s*(['""](?<key>.+)['""]|(?<key>\w+))\s*:\s*['""](?<value>.+)['""]\s*,?\s*$", RegexOptions.Multiline);

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var translations = new Dictionary<string, Dictionary<string, string>>();
        foreach (var file in context.AdditionalFiles)
        {
            var lang = Path.GetFileNameWithoutExtension(file.Path);
            var content = file.GetText(context.CancellationToken).ToString();
            var matches = _regex.Matches(content);
            var translation = new Dictionary<string, string>();
            foreach (Match match in matches)
            {
                translation[match.Groups["key"].Value] = match.Groups["value"].Value;
            }
            translations[lang] = translation;
        }

        var sb = new StringBuilder();

        sb.Append(@"// <auto-generated />

using System.Collections.Generic;

namespace ToastUI
{
    partial class EditorLanguage
    {
        static EditorLanguage()
        {");

        foreach (var translation in translations)
        {
            sb.Append(@$"
            Translations[""{translation.Key}""] = new Dictionary<string, string>
            {{");

            foreach (var item in translation.Value)
            {
                sb.Append(@$"
                {{ ""{item.Key}"", ""{item.Value}"" }},");
            }

            sb.Append(@"
            };");
        }

        sb.Append(@"
        }
    }
}
");

        context.AddSource("LanguageGenerator.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
